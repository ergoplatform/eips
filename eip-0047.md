- Author: aslesarenko
- Status: Proposed
- Created: 07-July-2024 
- Last edited: 07-July-2024
- License: CC0
- Forking: soft-fork

# EIP-0048: Pooled Transaction Inputs

## Background and Motivation

In the current implementation of the Ergo blockchain, each transaction spends a list of
UTXOs (called Boxes) given by their boxId. These input boxes need to be selected by an
off-chain selector, which is part of the transaction builder in the wallet. Once the
transaction is built and signed, these concrete Boxes are set in stone and cannot be
changed without rebuilding the transaction and re-signing it again.

### The Problem

This creates challenges when multiple transactions need to be created from the same wallet
in short period of time in response to external events (e.g. when participating in multiple
DeFi protocols). Two transactions cannot share the
same input box, so the wallet must track which boxes are already spent and which are not,
selecting non-overlapping subsets of UTXOs. However, this is not always feasible,
especially when UTXOs are consolidated into a single box, resulting in a situation where
only one transaction can be created from that single UTXO and other transactions has to be
chained which by itself creates undesirable dependency on the parent transaction so that
cancellation/delaying/queueing of the parent transaction will also cancel/delay/queue the
child transaction.

This problem is exacerbated in scenarios requiring responsiveness. For
example, if a user participates in two or more DeFi protocols involving some form of
transaction queueing and needs to react to multiple events quickly, user cannot chain
transactions belonging to different DeFi protocols, but has to submit them quickly in
response to the events. In such cases, the consolidation of UTXOs
can become a bottleneck, limiting the number of transactions that can be executed in
parallel. 

### Illustrative Example

Consider Alice, a user who actively participates in multiple DeFi protocols on the Ergo
blockchain. Each protocol requires Alice to submit transactions in response to various
events, such as staking rewards, yield farming updates, or automated trading triggers.
These interactions need to be executed promptly to maximize her returns and maintain her
positions.

Scenario:
 - Alice stakes some ERGs in a DeFi staking pool, which periodically pays out rewards.
 - She also participates in a yield farming protocol, which requires her to move funds
   between different liquidity pools based on real-time market conditions.
 - Additionally, Alice uses an automated trading bot that submits transactions based on
   market signals.

Each of these DeFi protocols requires Alice to submit transactions spending from her
wallet in response to the protocol-specific events. However, these transactions cannot be chained
together as they are built independently by different dApps. If Alice's wallet has
consolidated its funds into a single UTXO for storage efficiency, she can only process one
transaction at a time, leading to delays and potentially missed opportunities. 

For example, when a staking reward is paid out, Alice needs to quickly reinvest
these rewards into the yield farming protocol. Simultaneously, the trading bot may need to
execute a trade based on a market signal. If all these transactions depend on the same
UTXO, only one can be processed at a time, creating a bottleneck.

Alternatively, Alice can de-consolidate her UTXOs, but this additional step will worsen
user experience and increase time and cost of transactions. Even if implemented by wallet,
such add-hoc consolidation/de-consolidation once in a while will bottleneck Alice in her
DeFi experience.

### The Solution Idea

To address these challenges, we propose the introduction of _Pooled Transaction Inputs_.
This new mechanism allows transactions to specify input pools from which UTXOs can be
selected dynamically, rather than pre-selecting specific UTXOs. By introducing a new data
structure called `PooledInput`, we enable transactions to define _inputs to spend_ without
specifying concrete UTXOs at the time of transaction creation.

With `PooledInput`, Alice can define her transactions to spend from a pool of UTXOs
associated with her wallet's address, specifying the amount to be spent. This way,
multiple transactions can be created by different dApps and processed in parallel, each
spending from the same pool of UTXOs and without pre-determined boxIds. The Ergo node will
select (or _unpool_) the appropriate UTXOs for spending during transaction processing,
ensuring deterministic and conflict-free execution on L1 protocol level.

In Alice's case, this means she can handle staking rewards, yield farming updates, and
automated trades simultaneously, improving her DeFi interaction efficiency and
responsiveness. This solution allows her to create transactions simultaneously across
multiple dApps without the risk of transaction conflicts even in the
presence of queuing, delays or cancellations at individual applications.

By implementing Pooled Transaction Inputs, we aim to enhance the flexibility and
efficiency of UTXO management in Ergo, supporting higher throughput and more responsive
user experience especially in the context of cross-DeFi interactions. More on this in the
Benefits section.

## Proposed Solution

To address the challenges identified in the Background and Motivation section, we propose
the introduction of a new transaction input type called `PooledInput`. This new data
structure and its associated protocol modifications will enable transactions to
dynamically select UTXOs from a specified pool, enhancing the flexibility and efficiency
of transaction creation and execution on the Ergo blockchain.

### Key Components of the Solution

1. **PooledInput Data Structure** which contains the following fields:
  - `address: ErgoAddress`: Specifies the address from which UTXOs should be selected.
  - `value: Long`: The total value to be spent from the pool.

2. **Transaction Format Extension:**
  - Extend the existing transaction format to include a new field `pools: List[PooledInput]`,
    which is a list of `PooledInput`.

3. **Validation and Processing Logic:**
  - Modify the Ergo node to support the new transaction format with the `pools` field.
  - During transaction processing, the Ergo node will select UTXOs from the specified 
    address pool and have a total value greater than or equal to the `value` field of the
    `PooledInput`.

4. **Deterministic Box Selection:**
  - Implement a deterministic selection algorithm to ensure all nodes select the same UTXOs
    from the pool. This can be achieved by sorting the pool boxes by their order of inclusion
    into the UTXO set (which is defined by the global order of transactions in the
    blockchain). The first boxes from the ordered list are selected until the total value
    meets or exceeds the required `value`.

5. **LevelDB Integration for Efficient Box Selection:**

   - To efficiently manage UTXOs and ensure deterministic box selection, we propose leveraging
   LevelDB's ordered key-value storage. This approach maintains UTXOs in an ordered fashion
   based on `(address, blockHeight, outputIndex)`, where the value stored is the `boxId` of
   the UTXO.
   - Key Design:
     - Key: `(address, blockHeight, outputIndex)` formatted as a string to maintain order.
     - Value: `boxId` stored as bytes.
   - New Database Instance:
     - `indexDb`: Stores the ordered keys with the UTXO `boxId` as the value.

6. **Change Output Handling:**
  - After selecting the required UTXOs, the transaction will generate a change output with
    the remaining value (total value of selected UTXOs minus the `value` field of the
    `PooledInput`). This change output will be appended to the list of transaction
    outputs and the change amount will be returned to the address associated with the pool and
    thus can be immediately consumed by the next transaction spending from the same pool.

7. **Transaction Concretization:**
  - Introduce the process of `input unpooling`  during block
    validation. This involves determining the exact UTXOs (concrete boxes) to be spent based
    on the state of the UTXO set at the transaction's position in the block. This also
    includes adding the change output to the transaction outputs.

8. **Support for Multiple PooledInputs:**
  - Allow transactions to include multiple `PooledInputs` in the `pools` list. The unpooling
    process will handle each `PooledInput` sequentially, in the order they appear in the
    list.

### Avoiding Double-Spending with PooledInputs

While PooledInputs offer flexibility, they also introduce a potential risk (if
not addressed) of double-spending. Specifically, when a transaction contains only
PooledInputs, it can be submitted multiple times to the blockchain through different
network nodes, potentially spending from the same UTXO pools. This is possible because the
`messageToSign` for different submissions of the same transaction will be the same, making
the signature valid for each attempt. This loophole can be exploited for double-spending
attacks.

The classical solution to this problem involves incorporating a _nonce_ in the
`messageToSign` that increments with each transaction submission. However, this approach
is impractical for UTXO blockchains due to several reasons:
- The nonce is not part of the UTXO.
- There is no place to store the previous nonce in the UTXO state.
- Introducing a nonce would require significant changes to the UTXO model.
- The nonce would need to be persistently stored, adding inefficiency and requiring additional storage.
- Each transaction submission would require updating the nonce, which introduces a shared state.
- Wallet software would need to track the nonce for each UTXO pool, adding complexity.
- The transaction format and signing process would need to change to include the nonce,
  necessitating wallet software updates.

In this proposal, instead of using nonce, we address this issue by imposing a constraint
on the usage of PooledInputs and describe a convention for UTXO management that will make
this proposal both safe and also practical to implement. More on this in the Proposed
Solution section.

### Solution to Double-Spending Risk

To address the possibility of double-spending attacks with PooledInputs, we propose a
constraint: a transaction with PooledInputs must include at least one concrete input. This
ensures that each transaction has a unique piece of data in its `messageToSign`,
preventing duplicate submissions. The Ergo node will enforce this constraint during
transaction validation.

However, in many practical use cases, transactions with PooledInputs may not naturally have
concrete inputs, as seen in the examples described earlier. To address this, we propose a
convention for UTXO management supported by wallet software, which can be regarded as a
wallet standard (can be published as separate EIP motivated by this proposal).

#### Wallet Standard for PooledInputs

1. **PoolAccessBox**:
    - When creating a transaction with PooledInputs, the wallet should include a dummy input
      box called `PoolAccessBox` with a minimal value (pre-defined constant
      `PoolAccessBoxValue` of nanoERG). This box is spendable from the wallet's address
      and serves solely as a placeholder to ensure the transaction has at least one
      concrete input and thus have access to input pools.

2. **Maintaining PoolAccessBoxes**:
    - Every transaction spending `PoolAccessBox` should also create a new one in its outputs.
      This maintains a continuous supply of `PoolAccessBoxes` for future transactions and
      preserves the input/output balance.
    - Initially, the wallet software should create a sufficient number of `PoolAccessBoxes` to
      enable the PooledInputs feature. Subsequent management of these boxes will be
      handled internally by the wallet, ensuring user-friendly operation.

3. **User Experience**:
    - The wallet can prompt the user to enable the "Pooled Inputs" feature once enough ERGs
      are available, creating the necessary `PoolAccessBoxes` in a single transaction.
    - To distinguish `PoolAccessBoxes` from other boxes, they can have a specific register
      value (e.g., `R4 = 0x012345`). The wallet can identify available `PoolAccessBoxes`
      using (wallet's address, `R4 = 0x012345`, value == `PoolAccessBoxValue`).

### Implementation Details

#### PooledInput Data Structure
   The `PooledInput` structure can be defined in Scala as follows:
   ```scala
   case class PooledInput(
     address: SigmaProp,   // defines the pool where UTXOs are selected from
     value: Long,   // Total value to be spent from the pool
     signature: Array[Byte] // Signature for the `address` sigma proposition
   )
   ```
  - `SigmaProp` type: aka Sigma Proposition, specifies the source address of the UTXOs (in its simplest form it is P2PK, but can also be multisig and more complex sigma trees).
  - `value`: The total amount of ERGs to be covered by inputs spent from the pool.
  - `signature`: The signature for the `address` sigma proposition, ensuring the transaction
    is authorized to spend from the pool.

 The `address` field defines the UTXO pool as a list of boxes as if returned by the following query:
 ```sql
    SELECT * FROM UTXO as U 
    WHERE U.ergoTree = ErgoTree.fromSigmaProp(address)
 ```

#### Transaction Format Extension
   Extend the transaction format to include the `pools` field:
   ```scala
   case class ErgoTransaction(
     inputs: Seq[Input],          // List of concrete inputs to spend
     dataInputs: Seq[DataInput],  // List of data inputs
     pools: Seq[PooledInput],     // List of pooled inputs (UTXO pools) to spend from
     outputs: Seq[BoxCandidate]   // List of output boxes (not including change outputs created for each pooled input)
   )
   ```
  - `pools`: A list of `PooledInput` that each specify the list of UTXOs to be spent from 
    each pool during transaction processing. 
  - When the `pools` is empty (i.e., no pooled inputs), the transaction behaves as a 
    standard transaction with concrete inputs and data inputs.
  - When the `pools` list contain a simple P2PK address, then the corresponding signature
    should be present in the `signature` field of the `PooledInput`.
  - When the `pools` list contain addresses belonging to different wallets,
then properly generated signatures has to be provided in the `signature` fields of the
corresponding `PooledInput`s.
  - Technically, the format versioning is done using reusing one of the counts which is greater than
    MaxArrayLength (e.g. 100000), for example data inputs count. This is similar to how
    versioning is done in BlockTransactionsSerializer.

#### Validation and Processing Logic

   During transaction validation, the Ergo node will:
  - **Get the list of PooledInputs**:
    ```scala
    val pooledInputs = transaction.pools
    ```
  - **For each `PooledInput`, select UTXOs** from the specified address that sum up to the required value:
    ```scala
    pooledInputs.foreach { pooledInput =>
      val selectedUtxos = selectUtxos(pooledInput.address, pooledInput.value)
      transaction.inputs.appendAll(selectedUtxos.map(createInput))
    }
    ```
  - `selectUtxos(address, value)`: Selects UTXOs from the address until the total
     value meets or exceeds the specified value (see the `def` below).

#### Extension of UTXO Storage

To support the deterministic selection of UTXOs from a pool, we need to extend the UTXO
storage with additional information about each UTXO. Specifically, we need to store the
`blockHeight` and `outputIndex` for each UTXO as described below in order to be able to 
determine the order of UTXOs in the pool.

The UTXO storage needs to be extended to include the following additional fields for each
UTXO:

- `blockHeight`: The height of the block in which the UTXO was created. This is calculated
  as the height of the block where UTXO is created.

- `outputIndex`: This is calculated as the index of the output in the list of outputs of
  the full block that created the UTXO.

These fields are calculated in the `UtxoState.applyModifier` method during the processing
of each `Insert` operation. The `Insert` operation is submitted to the
`persistentProver.performOneOperation` method, which updates the UTXO set in the
persistent storage.

#### Deterministic Box Selection

To ensure deterministic and efficient selection of UTXOs for a given `PooledInput`, we use
LevelDB to efficiently (i.e. O(log(n)) time) store and retrieve UTXOs in an ordered manner
(using lexically ordered keys).

##### UTXO Storage and Key Design

Each UTXO is stored with a key consisting of `(address, blockHeight, outputIndex)` and the
`boxId` as the value. The UTXO data itself is stored separately in the
`PersistentBatchAVLProver` (field in `UtxoState`) with the `boxId` as the key.

```scala
def createKey(address: String, blockHeight: Long, outputIndex: Int): String = {
  f"$address%s-$blockHeight%010d-$outputIndex%05d"
}
```

##### Adding and Removing UTXOs

UTXOs are added to and removed from both the `indexDb` and the `PersistentBatchAVLProver`.
The logic is as follows:

```scala
val stateChanges = ErgoState.stateChanges(block)
stateChanges.foreach { change => change match {
    case (Insert(k, v), utxo) =>
      val key = createKey(utxo.address, utxo.blockHeight, utxo.outputIndex)
      indexDb.put(key, utxo.boxId)
      persistentProver.performOneOperation(Insert(k, v)) // existing code: add UTXO to the persistent storage
    case Remove(boxId) =>
      val utxo = persistentProver.unauthenticatedLookup(boxId).get
      val key = createKey(utxo.address, utxo.blockHeight, utxo.outputIndex)
      indexDb.delete(key)
      persistentProver.performOneOperation(Remove(boxId))
}}
```
##### Selecting UTXOs for Unpooling

To select UTXOs for a given PooledInput, we use an iterator to retrieve UTXOs in order
until the required value is met. The logic can be implemented as follows:

```scala
def selectUtxos(address: String, requiredValue: Long): Seq[UTXO] = {
  val iter = indexDb.iterator()
  val prefix = f"$address%s-"
  iter.seek(prefix.getBytes)
  var selectedUtxos = Seq.empty[UTXO]
  var totalSelectedValue = 0L

  while (iter.hasNext && totalSelectedValue < requiredValue) {
    val entry = iter.next()
    val keyStr = new String(entry.getKey)
    if (keyStr.startsWith(prefix)) {
      val boxId = new String(entry.getValue)
      val utxoBytes = persistentProver.unauthenticatedLookup(boxId).get
      val utxo = deserialize(utxoBytes)
      
      selectedUtxos = selectedUtxos :+ utxo
      totalSelectedValue += utxo.value
    }
  }

  iter.close()

  if (totalSelectedValue >= requiredValue) {
    selectedUtxos
  } else {
    Seq.empty[UTXO] // Or throw an error if the required value cannot be met
  }
}
```
By leveraging LevelDB's ordered storage, we ensure efficient and deterministic selection
of UTXOs for unpooling.

#### Change Output Handling
   After selecting the UTXOs, an optional change output is created to return the remaining
   coins to the pool. This is done as follows:
   ```scala
    def addChangeOutput(selectedUtxos: Seq[Utxo], pooledInput: PooledInput, transaction: ErgoTransaction): Unit = {
      val totalSelectedValue = selectedUtxos.map(_.value).sum
      val changeValue = totalSelectedValue - pooledInput.value
      if (changeValue > 0) {
        val changeOutput = createChangeOutput(changeValue, pooledInput.address)
        transaction.outputs.append(changeOutput)
      }
    }   
   ```
  - `totalSelectedValue`: Sum of values of the selected UTXOs.
  - `changeValue`: Difference between the total selected value and the required value.
  - `createChangeOutput(value, address)`: Creates a change output box with the specified 
    value and address, note the use of the same address as the pool.

#### Transaction Concretization
   When a transaction have at least one `PooledInput`, the transaction needs to be
   concretized, i.e. the exact UTXOs to be spent need to be determined along with the change
   outputs. This process is called `input unpooling` and is done during block application and
   validation. The concretization process can be implemented as follows:
   ```scala 
   def concretizeTransaction(tx: ErgoTransaction, utxoState: UtxoState): Unit = {
     tx.pools.flatMap { pooledInput =>
       val candidateUtxos = utxoState
           .getUtxos(pooledInput.address)
       val selectedUtxos = selectUtxos(candidateUtxos, pooledInput.value)
       val concretizedInputs = selectedUtxos.map(u => createInput(u))
       transaction.inputs.appendAll(concretizedInputs)
       addChangeOutput(selectedUtxos, pooledInput, transaction)
     }
   }
   ```
  - `concretizeTransaction`: Resolves `PooledInputs` into concrete inputs 
     based on the current UTXO state and adds change outputs.
  - `createInput(utxo)`: Converts a UTXO into a transaction input.
  -  Note, the method can handle multiple `PooledInput` by sequentially processing each
     entry in the `pools` list:
  - This ensures that each `PooledInput` is processed in the order they appear, with
    deterministic UTXO selection and conflict-free execution.

### Example: Alice's Multi-Step DeFi Workflow
Let's create a detailed example involving Alice's participation in multiple DeFi
protocols, requiring her to sign transactions and manage her UTXOs efficiently using the
Pooled Transaction Inputs mechanism.

#### Context
Alice is an active participant in the DeFi ecosystem on the Ergo blockchain. She engages
in multiple protocols, including staking, yield farming, and automated trading. She needs
to handle these interactions efficiently to maximize her returns.

#### Current Step-by-Step Workflow with explicit UTXO selection

1. **Initial Setup:**
    - **Wallet:** Alice's wallet contains the following UTXOs:
        UTXO1: 100 ERG 

2. **Staking:**
    - **Event:** Alice decides to stake 40 ERG in a DeFi staking pool that periodically pays out rewards.
    - **Transaction 1:** Alice creates a transaction to stake 40 ERG.
        - **Inputs:** UTXO1 (100 ERG)
        - **Outputs:**
            - StakeOutput: 40 ERG to the staking pool
            - ChangeOutput: 60 ERG back to Alice's wallet
    - Wallet: UTXO2: 60 ERG (unconfirmed)
   
3. **Yield Farming:**
    - **Event:** Alice wants to participate in a yield farming protocol that requires 35 ERG.
    - **Transaction 2:** Alice creates chained transaction to deposit 35 ERG into the yield farming pool
    referencing the change output from the previous transaction.
        - **Inputs:** UTXO2 (60 ERG) (unconfirmed)
        - **Outputs:**
            - YieldFarmOutput: 35 ERG to the yield farming pool
            - ChangeOutput: 25 ERG back to Alice's wallet
    - Wallet: UTXO3: 25 ERG (unconfirmed)

4. **Automated Trading:**
    - **Event:** Alice's automated trading bot detects a market signal and needs to execute a trade with 20 ERG.
    - **Transaction 3:** The bot creates a transaction to execute the trade.
        - **Inputs:** UTXO3 (25 ERG) (unconfirmed)
        - **Outputs:**
            - TradeOutput: 20 ERG to the trading pool
            - ChangeOutput: 5 ERG back to Alice's wallet
    - Wallet: UTXO4: 5 ERG (unconfirmed)

Note, in order for Alice to execute the above transaction in parallel, they all need to be
chained together. This creates hard dependence between the transactions and requires all
the previous (parent) transactions to be successful for child transactions to also be
successful. This rules out any possibility for cancellation or transaction queueing on
DeFi protocol side. If Transaction 1 is cancelled/delayed by the DeFi protocol, then
the whole chain of transactions will be also cancelled/delayed.

#### New step-by-step Workflow with Pooled Inputs

Note:
- to ensure the security and uniqueness of transactions involving PooledInputs,
Alice's wallet will include a `PoolAccessBox` in each transaction. 
- many access boxes can be created initially to enable PooledInputs feature in the wallet
- the number of access boxes defines the maximum number of transactions that can be created
  in parallel without using chaining.

1. **Initial Setup**:
    - **Wallet**: Alice's wallet contains the following UTXOs:
        - UTXO1: 100 ERG
        - PoolAccessBox1: 0.001 ERG (pre-defined constant `PoolAccessBoxValue`)
        - PoolAccessBox2: 0.001 ERG
        - PoolAccessBox3: 0.001 ERG

2. **Staking**:
    - **Transaction 1**: Alice creates a transaction to stake 40 ERG.
        - **PooledInput**:
            - Address: Alice's Wallet Address
            - Value: 40 ERG
            - Signature: Alice's Signature
        - **Concrete Input**: PoolAccessBox1 (0.001 ERG)
        - **Outputs**:
            - StakeOutput: 40 ERG to the staking pool
            - PoolAccessBox4: 0.001 ERG to Alice's wallet

3. **Yield Farming**:
    - **Transaction 2**: Alice creates a transaction to deposit 35 ERG into the yield farming pool.
        - **PooledInput**:
            - Address: Alice's Wallet Address
            - Value: 35 ERG
            - Signature: Alice's Signature
        - **Concrete Input**: PoolAccessBox2 (0.001 ERG)
        - **Outputs**:
            - YieldFarmOutput: 35 ERG to the yield farming pool
            - PoolAccessBox5: 0.001 ERG to Alice's wallet

4. **Automated Trading**:
    - **Transaction 3**: The bot creates a transaction to execute a trade with 20 ERG.
        - **PooledInput**:
            - Address: Alice's Wallet Address
            - Value: 20 ERG
            - Signature: Alice's Signature
        - **Concrete Input**: PoolAccessBox3 (0.001 ERG)
        - **Outputs**:
            - TradeOutput: 20 ERG to the trading pool
            - PoolAccessBox6: 0.001 ERG to Alice's wallet

This workflow ensures that each transaction has a unique `messageToSign`, preventing
double-spending attacks while maintaining the flexibility and efficiency of PooledInputs.

#### Benefits of Pooled Transaction Inputs
- wallet doesn't need to chain transactions and select UTXOs explicitly
- no need to add change outputs explicitly (the change is handled by the network on the protocol level)
- transactions can be sent in any order (or all at once) and don't depend on each other
- any transaction can be cancelled/delayed/queued without affecting others

#### Conclusion

The introduction of Pooled Transaction Inputs and the use of `PoolAccessBox` significantly
streamline the process of managing multiple DeFi interactions for users like Alice. By
allowing transactions to specify input pools rather than fixed UTXOs, and ensuring each
transaction includes at least one concrete input, users can engage in various DeFi
protocols simultaneously without chaining transactions or managing UTXO dependencies. This
approach not only enhances transaction flexibility and efficiency but also prevents
double-spending attacks, enabling a more secure and responsive DeFi experience on UTXO
blockchain platform such as Ergo.

Furthermore, Pooled Transaction Inputs and `PoolAccessBox` mitigate challenges associated
with UTXO consolidation, allowing users to maximize their participation in the DeFi
ecosystem without transaction processing limitations. This proposal represents a
significant step forward in the scalability and usability of the Ergo blockchain, paving
the way for more complex and dynamic DeFi applications.

The implementation of Pooled Transaction Inputs and `PoolAccessBox` as a wallet convention
simplifies UTXO management, ensuring that transactions are both secure and efficient. This
user-friendly approach enhances the DeFi experience on the Ergo blockchain.
