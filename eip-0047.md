
# EIP-0048: Pooled Transaction Inputs

## Background and Motivation

In the current implementation of the Ergo blockchain, each transaction spends a list of
UTXOs (called Boxes) given by their boxId. These input boxes need to be selected by an
off-chain selector, which is part of the transaction builder in the wallet. Once the
transaction is built and signed, these concrete Boxes are set in stone and cannot be
changed without rebuilding the transaction and re-signing it again.

### The Problem

This creates challenges when multiple transactions need to be created from the same wallet
in short period of time in response to external events. Two transactions cannot share the
same input box, so the wallet must track which boxes are already spent and which are not,
selecting non-overlapping subsets of UTXOs. However, this is not always feasible,
especially when UTXOs are consolidated into a single box, resulting in a situation where
only one transaction can be created from that single UTXO and other transactions has to be
chained.

This problem is exacerbated in scenarios requiring responsiveness. For
example, if a wallet participates in two or more DeFi protocols and needs to react to
multiple events quickly, it cannot chain transactions and has to submit them quickly in
response to the events. In such cases, the consolidation of UTXOs
can become a bottleneck, limiting the number of transactions that can be executed in
parallel. Moreover, in a chain of transactions, any subsequent transaction needs to know
the boxIds of the boxes created by the previous transaction, requiring the entire chain to
be built with knowledge of all boxIds, both existing and future, which rules out any
possibility for conditional chaining.

### Illustrative Example

Consider Alice, a user who actively participates in multiple DeFi protocols on the Ergo
blockchain. Each protocol requires Alice to submit transactions in response to various
events, such as staking rewards, yield farming updates, or automated trading triggers.
These interactions need to be executed promptly to maximize her returns and maintain her
positions.

Scenario:
 - Alice stakes some ERGs in a DeFi staking pool, which periodically pays out rewards.
 - he also participates in a yield farming protocol, which requires her to move funds
   between different liquidity pools based on real-time market conditions.
 - Additionally, Alice uses an automated trading bot that submits transactions based on
   market signals.

Each of these DeFi protocols requires Alice to submit transactions spending from her
wallet in response to the protocol-specific events. However, these transactions cannot be chained
together as they are built independently by different dApps. If Alice's wallet has
consolidated its funds into a single UTXO for storage efficiency, she can only process one
transaction at a time, leading to delays and potentially missed opportunities.

For example, when a staking reward is paid out, Alice needs to quickly reinvest
these rewards into the yield farming protocol. Simultaneously, the trading bot may need to
execute a trade based on a market signal. If all these transactions depend on the same
UTXO, only one can be processed at a time, creating a bottleneck.

### The Solution

To address these challenges, we propose the introduction of Pooled Transaction Inputs.
This new mechanism allows transactions to specify input pools from which UTXOs can be
selected dynamically, rather than pre-selecting specific UTXOs. By introducing a new data
structure called `PooledInput`, we enable transactions to define inputs to spend without
specifying concrete UTXOs at the time of transaction creation.

With `PooledInput`, Alice can define her transactions to spend from a pool of UTXOs
associated with her wallet's address, specifying the amount to be spent and optional
selection filters. This way, multiple transactions can be created by different dApps and
processed in parallel, each spending from the same pool of UTXOs and without
pre-determined boxIds. The Ergo node will select ("unpool") the appropriate UTXOs for
spending during transaction processing, ensuring deterministic and conflict-free execution.

In Alice's case, this means she can handle staking rewards, yield farming updates, and
automated trades simultaneously, improving her DeFi interaction efficiency and
responsiveness. This solution allows her to maximize her returns and maintain her
positions across multiple protocols without the risk of transaction delays or conflicts.

By implementing Pooled Transaction Inputs, we aim to enhance the flexibility and
efficiency of UTXO management in Ergo, supporting higher throughput and more responsive
user experience.

## Proposed Solution

To address the challenges identified in the Background and Motivation section, we propose
the introduction of a new transaction input type called `PooledInput`. This new data
structure and its associated protocol modifications will enable transactions to
dynamically select UTXOs from a specified pool, enhancing the flexibility and efficiency
of transaction creation and execution on the Ergo blockchain.

### Key Components of the Solution

1. **PooledInput Data Structure** which contains the following fields:
  - `address: ErgoAddress`: Specifies the address from which UTXOs should be selected.
  - `filter: Option[Predicate]`: An optional predicate to filter the UTXOs within the pool, 
    allowing for more granular selection criteria.
  - `value: Long`: The total value to be spent from the pool.

2. **Transaction Format Extension:**
  - Extend the existing transaction format to include a new field `pools: List[PooledInput]`,
    which is a list of `PooledInput`.

3. **Validation and Processing Logic:**
  - Modify the Ergo node to support the new transaction format with the `pools` field.
  - During transaction processing, the Ergo node will select UTXOs from the specified 
    address pool that satisfy the filter and have a total value greater than or equal to 
    the `value` field of the `PooledInput`.

4. **Deterministic Box Selection:**
  - Implement a deterministic selection algorithm to ensure all nodes select the same UTXOs
    from the pool. This can be achieved by sorting the pool boxes by their order of inclusion
    into the UTXO set (which is defined by the global order of transactions in the
    blockchain). The first boxes from the sorted list are selected until the total value
    meets or exceeds the required `value`.

5. **Change Output Handling:**
  - After selecting the required UTXOs, the transaction will generate a change output with
    the remaining value (total value of selected UTXOs minus the `value` field of the
    `PooledInput`). This change output will be appended to the list of transaction
    outputs and the change amount will be returned to the address associated with the pool and
    thus can be immediately consumed by the next transaction spending from the same pool.

6. **Transaction Concretization:**
  - Introduce the process of `input unpooling`  during block
    validation. This involves determining the exact UTXOs (concrete boxes) to be spent based
    on the state of the UTXO set at the transaction's position in the block. This also
    includes adding the change output to the transaction outputs.

7. **Support for Multiple PooledInputs:**
  - Allow transactions to include multiple `PooledInputs` in the `pools` list. The unpooling
    process will handle each `PooledInput` sequentially, in the order they appear in the
    list.

### Implementation Details

#### PooledInput Data Structure
   The `PooledInput` structure can be defined in Scala as follows:
   ```scala
   case class PooledInput(
     address: SigmaProp,   // defines the pool where UTXOs are selected from
     filter: Option[Predicate],   // Optional filter to select specific UTXOs
     value: Long,   // Total value to be spent from the pool
     signature: Array[Byte] // Signature for the `address` sigma proposition
   )
   ```
  - `SigmaProp` type: aka Sigma Proposition, specifies the source address of the UTXOs (including multisig).
  - `Predicate` type: A filter condition that UTXOs must satisfy to be considered for selection. 
    This is implemented as ErgoTree lambda of type `Box => Boolean`, i.e. it takes a box as
    argument and can filter UTXOs boxes based on their registers.
  - `value`: The total amount of ERGs to be covered by inputs spent from the pool.
  - `signature`: The signature for the `address` sigma proposition, ensuring the transaction
    is authorized to spend from the pool.

 The two fields `address` and `filter` define the UTXO pool as a list of boxes as if
 returned by the following query:
 ```sql
    SELECT * FROM UTXO as U 
    WHERE U.ergoTree = ErgoTree.fromSigmaProp(address) and filter(U)
 ```

#### Transaction Format Extension
   Extend the transaction format to include the `pools` field:
   ```scala
   case class ErgoTransaction(
     inputs: Seq[Input],          // List of concrete inputs to spend
     dataInputs: Seq[DataInput],  // List of data inputs
     pools: Seq[PooledInput],     // List of pooled inputs (UTXO pools) to spend from
     outputs: Seq[BoxCandidate]   // List of output boxes (not including change outputs created for each pooled input)
   )
   ```
  - `pools`: A list of `PooledInput` that each specify the list of UTXOs to be spent from 
    each pool during transaction processing. 
  - When the `pools` is empty (i.e., no pooled inputs), the transaction behaves as a 
    standard transaction with concrete inputs and data inputs.
  - When the `pools` list contain a simple P2PK address, then the corresponding signature
    should be present in the `signature` field of the `PooledInput`.
  - When the `pools` list contain addresses belonging to different wallets,
then properly generated signatures has to be provided in the `signature` fields of the
corresponding `PooledInput`s.

#### Validation and Processing Logic
   During transaction validation, the Ergo node will:
  - **Parse the `pools` field**:
    ```scala
    val pooledInputs = transaction.pools
    ```
  - **For each `PooledInput`, select UTXOs** from the specified address that satisfy the 
    filter and meet the required value:
    ```scala
    pooledInputs.foreach { pooledInput =>
      val candidateUtxos = getUtxosFromAddress(pooledInput.address).filter(pooledInput.filter.getOrElse(_ => true))
      val selectedUtxos = selectUtxos(candidateUtxos, pooledInput.value)
      transaction.inputs.appendAll(selectedUtxos.map(createInput))
    }
    ```
    - `getUtxosFromAddress(address)`: Retrieves all UTXOs associated with the given address.
    - `filter(predicate)`: Applies the optional filter to the UTXOs.
    - `selectUtxos(utxos, value)`: Selects UTXOs from the filtered list until the total
       value meets or exceeds the specified value.

#### Extension of UTXO Storage

To support the deterministic selection of UTXOs from a pool, we need to extend the UTXO
storage with additional information about each UTXO. Specifically, we need to store the
`blockHeight` and `outputIndex` for each UTXO as described below in order to be able to 
determine the order of UTXOs in the pool.

The UTXO storage needs to be extended to include the following additional fields for each
UTXO:

- `blockHeight`: The height of the block in which the UTXO was created. This is calculated
  as the height of the block where UTXO is created.

- `outputIndex`: This is calculated as the index of the output in the list of outputs of
  the full block that created the UTXO.

These fields are calculated in the `UtxoState.applyModifier` method during the processing
of each `Insert` operation. The `Insert` operation is submitted to the
`persistentProver.performOneOperation` method, which updates the UTXO set in the
persistent storage.

#### Deterministic Box Selection
   The selection algorithm will retrieve UTXOs in order of their inclusion into the UTXO set
   using `blockHeight` and `outputIndex` fields. The algorithm can be implemented as follows:
   ```scala
   def selectUtxos(utxos: Seq[Utxo], requiredValue: Long): Seq[Utxo] = {
     val sortedUtxos = utxos.sortBy(u => (u.blockHeight, u.outputIndex))
     var selectedUtxos = Seq.empty[Utxo]
     var totalSelectedValue = 0L

     for (utxo <- sortedUtxos if totalSelectedValue < requiredValue) {
       selectedUtxos = selectedUtxos :+ utxo
       totalSelectedValue += utxo.value
     }

     selectedUtxos
   }
   ```
  - `sortBy(u => (u.blockHeight, u.outputIndex))`: Sorts UTXOs first by blockHeight and then by outputIndex.
  - The selected UTXOs are those whose cumulative value meets or exceeds the required value.

#### Change Output Handling
   After selecting the UTXOs, an optional change output is created to return the remaining
   coins to the pool. This is done as follows:
   ```scala
    def addChangeOutput(selectedUtxos: Seq[Utxo], pooledInput: PooledInput, transaction: ErgoTransaction): Unit = {
      val totalSelectedValue = selectedUtxos.map(_.value).sum
      val changeValue = totalSelectedValue - pooledInput.value
      if (changeValue > 0) {
        val changeOutput = createChangeOutput(changeValue, pooledInput.address)
        transaction.outputs.append(changeOutput)
      }
    }   
   ```
  - `totalSelectedValue`: Sum of values of the selected UTXOs.
  - `changeValue`: Difference between the total selected value and the required value.
  - `createChangeOutput(value, address)`: Creates a change output box with the specified 
    value and address, note the use of the same address as the pool.

#### Transaction Concretization
   When a transaction have at least one `PooledInput`, the transaction needs to be
   concretized, i.e. the exact UTXOs to be spent need to be determined along with the change
   outputs. This process is called `input unpooling` and is done during block application and
   validation. The concretization process can be implemented as follows:
   ```scala 
   def concretizeTransaction(tx: ErgoTransaction, utxoState: UtxoState): Unit = {
     tx.pools.flatMap { pooledInput =>
       val candidateUtxos = utxoState
           .getUtxos(pooledInput.address)
           .filter(pooledInput.filter.getOrElse(_ => true))
       val selectedUtxos = selectUtxos(candidateUtxos, pooledInput.value)
       val concretizedInputs = selectedUtxos.map(u => createInput(u))
       transaction.inputs.appendAll(concretizedInputs)
       addChangeOutput(selectedUtxos, pooledInput, transaction)
     }
   }
   ```
  - `concretizeTransaction`: Resolves `PooledInputs` into concrete inputs 
     based on the current UTXO state and adds change outputs.
  - `createInput(utxo)`: Converts a UTXO into a transaction input.
  -  Note, the method can handle multiple `PooledInput` by sequentially processing each
     entry in the `pools` list:
  - This ensures that each `PooledInput` is processed in the order they appear, with
    deterministic UTXO selection and conflict-free execution.

